# Contributing

## Basics

The application uses [Vue 2.x](https://vuejs.org/v2/guide/) with
[Vuetify 2.x](https://vuetifyjs.com/en/introduction/why-vuetify/) as a UI component library, and
uses custom UI Elements only if strictly necessary (see [`src/views/lib`](src/views/lib)). All
components are written in Typescript. Tests are run with Playwright. The color scheme of the
application is defined in [`src/plugins/vuetify.ts`](src/plugins/vuetify.ts).

For practical development purposes, the following two pieces of software are wholeheartedly
recommended:

- [Volar for Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=vue.volar)
- [Vue.js Devtools for Google Chrome](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)

## Hosting

The SPA is served from a Node.js based Express server, handling the static files (see
[`server/index.ts`](server/index.ts)). The built-in server also performs other (minor) duties (i. e.
proxying/caching Zotero responses and providing the "Event Bus" — see below).

## REST API calls / RPC

The Back End provides an OpenAPI (née Swagger) spec. By calling `npm run generate:api-client`, the
spec is downloaded and transformed into a statically typed TS API client. All calls to the Back End
are then made through this API client. When the client is generated by the
[`openapi-typescript-codegen`](https://www.npmjs.com/package/openapi-typescript-codegen) module, we
also "inject" a custom request handler, located in
[`src/service/request.ts`](src/service/request.ts) which handles things like errors, the login
process and request states. During the build phase, it is copied to
[`src/api/core/request.ts`](src/api/core/request.ts), and then run from there — thus, if you want to
modify the request handler, modify it in [`src/service`](src/service), and then run
`npm run generate:api-client` to try it out.

The auto-generated types are also used extensively throughout the code base.

## State Management

The application state is not stored inside a traditional Vuex State Container, but instead in bare
Typescript classes located in [`src/store`](src/store). Their instance methods are used to mutate
their state. They also subscribe to remote changes and emit events, as described below. In all
stores, state variables that can only be mutated by a class member but can be read by the public,
are marked `private`, prefixed with an underscore and use a `getter` (but no setter) for public read
access. This means the app will not compile if (for instance) a component controller tries to modify
a store's state directly.

Currently, all Lemmas are stored, searched and filtered on the client in an IndexedDB table (called
`LemmaDb`). On start-up, we fetch the updates, inserts and deletions from the server, and update the
local database accordingly (all of this happens in the lemma class / store).

## Real-Time Synchronization

Clients keep each other up to date by connecting to a remote "Event Bus" (a WebSocket server),
provided by the built-in Node.js server (see [`server/index.ts`](server/index.ts)). Clients receive
Events when the data is changed by another. The Back End can also send specific types of Events by
`POST`ing to paths starting with `/message` — for instance when a Lemma's scrape data is updated by
the server. This only works if a secret key is provided in the request header. All `NotifyEvents`
are statically typed and thus conveniently enumerated in
[`src/service/notify.ts`](src/service/notify/notify.ts)`.

## Zotero data caching

Upon initialization the built in server starts caching responses from the Zotero API that rarely
change (specifically the `ItemTypeFields` for every type of publication).

## Editor

The Editor component makes heavy use of [ProseMirror](https://prosemirror.net)'s API, data
structures and nomenclature both via [TipTap 2](https://tiptap.dev) and directly. Familiarity with
the respective APIs is probably necessary for productive development.

## Project setup

### Prerequisites

- [node.js v18](https://nodejs.org/de/download)

### Set up environment variables

Server-side secrets should go into `.env.local` to not be committed to `git`. Start by copying
`.env.local.example`:

```bash
cp .env.local.example
```

Client-side build-args should go into `.env.development` (for a development build) and
`.env.production` (for a production build).

The `.env.development` file included in this repository assumes everything, including the backend,
is run locally. You can overwrite this to use a remote backend server by adding a
`.env.development.local` file (which will be gitignored):

```
# .env.development.local
ALLOWED_ORIGIN=["http://localhost:8080"]
VUE_APP_API_HOST="https://oebl-irs-backend.acdh-dev.oeaw.ac.at"
VUE_APP_EVENTBUS_HOST="http://localhost:3333"
VUE_APP_WEBAPP_HOST="http://localhost:8080"
```

Similarly, the `.env.production` file included in this repository assumes everyhing is deployed. You
can overwrite this to run a local production build by adding a `.env.production.local` file (which
will be gitignored):

```
# .env.production.local
ALLOWED_ORIGIN=["http://localhost:3333"]
VUE_APP_API_HOST="https://oebl-irs-backend.acdh-dev.oeaw.ac.at"
VUE_APP_EVENTBUS_HOST="http://localhost:3333"
VUE_APP_WEBAPP_HOST="http://localhost:3333"
```

### Install dependencies

```bash
npm install
```

### Run a development build

```bash
npm run dev
```

This will run an `express` server on [http://localhost:3333](http://localhost:3333) and a `webpack`
development server on [http://localhost:8080](http://localhost:8080).

### Run a production build

```bash
npm run build
npm run start
```

This will run an `express` server on [http://localhost:3333](http://localhost:3333) which will also
serve the bundled Vue app.

### Linting

We use `prettier` for formatting, as well as `eslint` and `stylelint` for linting TypeScript and
CSS.

```bash
npm run format:check
npm run lint:check
```

To automatically fix any auto-fixable errors:

```bash
npm run format:fix
npm run lint:fix
```

### Testing

We use `playwright` for end-to-end testing. To run tests against a local development build:

```bash
npm run test:e2e
```

To run tests against a local production build:

```bash
npm run build
npm run test:e2e:prod
```

### CI/CD

We have two GitHub workflows:

- Validate: runs linters and tests on every pull request, and on every push to `development` and
  `main` branches
- Build and deploy: builds a Docker image and deploys that production build to the ACDH-CH cluster
  on every push to `development` and `main` branches

## testing

```bash
npm run test:e2e
```

```bash
npm run test:e2e:prod
```
